 Hola a todos, continuando con la serie de videos del curso teórico de la IoT, en un video pasado ya hablamos del protocolo HTTP. Ahora, en este video, vamos a hablar sobre el protocolo MQTT. El protocolo MQTT se adapta para los casos en el que queremos mandar o recibir información a tiempo real de forma asíncrona. A diferencia de HTTP, aquí no tenemos que hacer un emparejamiento previo con el servidor. MQTT fue diseñado por ingenieros de IBM y es muy usado para controlar procesos de forma remota utilizando comunicación TCP IP. Entre sus ventajas encontramos que requiere poco ancho de banda, es un protocolo abierto que cualquiera los puede utilizar, consume poca energía, es muy rápido y por eso posibilita un tiempo de respuesta superior al resto de protocolos web actuales, requiere pocos recursos, procesadores y memorias, permite una gran fiabilidad y es ideal para redes inalámbricas. Es justamente por estas ventajas que este protocolo se adapta para trabajar con dispositivos con poca capacidad de cómputo como micro controladores o tarjetas IoT. Este protocolo, al igual que HTTP, se encuentra en la capa de aplicación del modelo TCP IP. En cuanto a la estructura del mensaje del MQTT, podemos identificar tres partes. Primero tenemos un encabezado fijo de 2 bytes como mínimo y 5 bytes como máximo. En este encabezado va los tipos de paquetes, la longitud del payload y el factor de calidad o QoS. El factor de calidad lo vamos a detallar cuando hablemos de las características del MQTT. Bien, continuando con la estructura del MQTT, tenemos otro encabezado de longitud variable. Es variable porque depende del tipo de mensaje, es decir, del ID, el tópico, entre otros. Cuando veamos la topología del MQTT, vamos a explicar estos conceptos. Y por último, tenemos el payload del mensaje que tiene una capacidad de hasta 256 megabytes. Ahora vamos a hablar de la topología del MQTT. MQTT utiliza una topología de tipo estrella, en la cual existe un nodo central que hace de servidor o también llamado broker. Y este es el encargado de gestionar la red y de transmitir los mensajes para mantener activo el canal. Su tarea principal es la de reenviar la información. Los brokers generalmente tienen una capacidad de conectar 10.000 clientes. Los clientes se pueden dividir en suscriptores y publicadores. Los publicadores o publisher son los que mandan información al broker, y los suscriptores o subscribers recogen la información. Cabe indicar que un cliente puede cambiar su estado. Es decir, para algunas ocasiones se puede comportar como un publicador, y para otra ocasión se puede comportar como suscriptor. Si el caso lo amerita, el cliente puede comportarse como suscriptor y publicador al mismo tiempo. Asimismo, la comunicación puede darse de cuatro formas posibles. Primero, de uno a uno. Por ejemplo, un SP32 manda la información del sensor de HT11 a una máquina virtual. Podemos ver que un publicador manda su payload a un suscriptor. Otra forma de comunicación es de uno a muchos. Por ejemplo, un SP32 manda la información del de HT11 a una máquina virtual y a una app en un celular. Aquí podemos ver que un publicador manda su payload a varios suscriptores. La otra forma de comunicación es de muchos a uno. Por ejemplo, un SP32 y un SP8266 mandan información de sus sensores a una máquina virtual. Aquí podemos ver que varios publicadores mandan su payload a un suscriptor. Y también se puede dar el caso en el que muchos publicadores se conectan a muchos suscriptores. Por ejemplo, un SP32 y un SP8266 mandan la información de sus sensores a una máquina virtual y a una app. Aquí podemos ver que varios publicadores mandan su payload a varios suscriptores. En todos los ejemplos observamos que la información pasa por el broker. Entonces, cuando un publicador establece un canal de comunicación, a ese canal se le llama tópico. Al tópico nosotros le podemos poner un nombre. Supongamos que tenemos estos dos suscriptores y dos publicadores. En nuestro caso, a un canal lo llamaremos canal 1 y al otro lo llamaremos canal 2. Consideremos que con el DHT11 estamos midiendo la temperatura del ambiente y con el otro sensor medimos la humedad del suelo. Ese dato que transmitimos lo llamamos payload. En el canal 1, el payload es 27 grados centígrados y en el canal 2, el payload es de 60% que corresponde al porcentaje de humedad de suelo. Bien, digamos que el suscriptor 1, que es el ordenador en la nube, quiere recibir los datos del SP8266. Entonces, se tiene que suscribir a ese canal apuntando al tópico canal 2 y cuando se suscriba recibirá el payload. Lo mismo ocurre con el aplicativo si quiere recibir los datos del SP32. Así también, la máquina virtual o la app podrían recibir el payload de ambas tarjetas. Simplemente se tendrían que suscribir a los dos canales. Además, podría haber un cambio de roles. La SP32 y la SP8266 podrían ser configurados como suscriptores y recibir el payload de la máquina virtual o la app según lo deseen. Entonces, ya que conocemos todo esto, vamos a repasar todas las características más importantes de MQTT. Como vemos, MQTT es un protocolo de publicación-suscripción. Esta comunicación asíncrona resulta útil en aplicaciones donde existan muchos clientes. Además, este protocolo, a diferencia de HTTP, no depende del mensaje que se envíe. En HTTP, el mensaje que se envía depende de los métodos que empleemos y de la cabecera y cuerpo que mandemos. Otra característica es que este protocolo se ejecuta sobre TCP y P y pertenece a la capa de aplicación. También, MQTT presenta tres calidades de servicio, 0, 1 y 2. La calidad de servicio 0 garantiza de que por lo menos se enviará un mensaje desde el publicador al suscriptor. Aunque no garantiza que dicho mensaje lo reciba el suscriptor. Es decir, puede haber mensajes perdidos. La calidad de servicio 1 garantiza de que por lo menos llegara un mensaje al suscriptor desde el publicador, aunque también le puede llegar más de uno, es decir, le pueden llegar mensajes duplicados. La calidad de servicio 2 garantiza de que llegará exactamente un mensaje desde el publicador al suscriptor. No habrá mensajes perdidos ni duplicados. En cuanto al ancho de banda, la calidad de servicio 0 es el que menos ancho de banda usa, y la calidad de servicio 2 es el que más ancho de banda usa. Dependiendo de lo que se necesite, configuraremos la calidad de servicio que más nos convenga. Además, este protocolo dispone de una función de última voluntad. Esto significa que si un cliente se desconectó de la red, ya sea porque se fue el internet u otro problema, automáticamente esta desconexión se notifica al broker. Y el broker notifica esta desconexión a todos los suscriptores de dicho cliente. Esto es bastante útil si estás controlando un proceso de automatización. De esta forma sabrás que un sensor está desconectado. Bien, ahora veremos cuáles son los parámetros para los clientes y el broker. Cuando el publicador quiere mandar mensajes al suscriptor, se tiene que hacer lo siguiente. En el publicador primero, debemos colocar la IP del equipo donde está el broker. También el puerto correspondiente que use el broker, el tópico y finalmente colocar el payload. Además, en el suscriptor, para recibir el mensaje, debemos colocar la IP del broker, el puerto y el tópico. Cuando el suscriptor recoge un mensaje, este no sabe quién lo ha enviado, ya que todo pasa por el broker. El puerto estándar que usa MQTT es el puerto 1883. Y para el MQTT cifrado, o también llamado MQTTS, se usa el puerto 8883. Además, al dispositivo cliente se le debe definir un ID o identificador único. Estos identificadores no se pueden repetir. Otro parámetro es el Keep Alive Time. El broker y el cliente se envían señales para confirmar que los clientes sigan conectados. Este envío de señales se hace de forma automática sin necesidad de que nosotros lo configuremos. El PINREC es el paquete enviado desde el cliente al broker. Y el PINRESP es el paquete enviado desde el broker al cliente. Entonces, el Keep Alive Time es el tiempo en segundos que el broker esperará a que el cliente responda al paquete PINRESP. Si no responde, será considerado como desconectado. Otro parámetro es la calidad de servicio o QoS. Esto ya hablamos en la sección de características. Bien, en el broker un parámetro opcional que se puede configurar es el de la autenticación. La autenticación se pone cuando queramos registrar los dispositivos clientes con un usuario y contraseña. De esta forma se mejora la seguridad para que solo los dispositivos registrados puedan comunicarse. Además, en el broker se configura el cifrado. Este puede ser SSL o TLS. Bien, dentro del protocolo MQTT existen librerías para prácticamente cualquier lenguaje de programación. Eso incluye a los más populares como Arduino, Java, JavaScript, Python, C-Sharp, entre otros. La librería MQTT para Arduino se llama PubSubClient. De hecho, en uno de los videos del IoT con SP32 programamos en Arduino IDE un SP32 utilizando esta librería para realizar una comunicación MQTT con Node-RED. Además, entre los brokers open source más populares que se pueden usar se encuentran Mosquito escrito en C++, también Mosquete escrito en Java y Mosca escrito en JavaScript. Los brokers se pueden instalar en el suscriptor, en el publicador o en un tercer dispositivo. Bueno, eso sería todo por este video. Para que esta explicación teórica te quede más clara, puedes revisar la lista del curso del IoT con SP32, donde usaremos el protocolo MQTT para transmitir datos desde el SP32 a Node-RED. No olvides dejar un like y suscribirte si este video te fue de ayuda. Gracias.
