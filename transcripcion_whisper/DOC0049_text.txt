 Fue hace medio año cuando OpenAI con Githat Copilot y luego Codex demostró que, bueno, pues que la inteligencia artificial podía aprender a programar. Ellos tienen el primer golpe sobre la mesa a la hora de presentar un sistema de inteligencia artificial que por primera vez demostraba un muy buen rendimiento a la hora de generar código de programación que cumplía con aquellas demandas que el usuario había descrito. Esto, como digo, fue el primer paso hacia inteligencias artificiales que estaban aprendiendo a programar. Y mucho de vosotros que habéis trabajado mano a mano con Codex me lo habéis comentado. Esta se ha convertido en una herramienta que verdaderamente agiliza vuestro flujo de trabajo a la hora de programar autocompletando de manera inteligente aquellas partes de código que por lo general íbamos a copiar a esta cover flow. Ahora, Codex no es aún una superinteligencia artificial a la que tú le puedas pedir oye, générame el código de este videojuego de plataformas o générame un código que resuelva este problema. Aún no. Codex está entrenado para resolver tareas que son relativamente sencillas y que puedan ser resueltas en pocas líneas de código. Y no pasa nada, es normal. Al final esta no deja de ser una de las primeras versiones que tenemos de este tipo de tecnologías. Y ahora es cuando yo diría algo así como será cuestión de años y no meses hasta que un sistema como Codex evolucione hasta convertirse en algo mucho más potente. Y no me equivocaría. Porque esto es justamente lo que ha pasado. Y es que pocos meses después de la gran presentación de Codex el otro gran laboratorio de inteligencia artificial, DeepMind, ha entrado también al juego de las inteligencias artificiales que aprenden a programar. Y lo han hecho con mucha fuerza. De la compañía que se propuso dominar el juego de mesa Go y acabó ganando al campeón del mundo con AlphaGo. La compañía que se propuso enseñar a una inteligencia artificial a jugar al StarCraft y lo consiguió con AlphaStar. El laboratorio que se propuso resolver uno de los problemas científicos más relevantes de la época. El plegado de proteínas. Y acabó revolucionando el campo de la biología estructural con su sistema AlphaFold. Ahora entra de lleno en la automatización de la programación con su nuevo sistema AlphaCode. Me encanta el jueguito este que se traen con los nombres de llamar a todo AlphaFold, AlphaStar, AlphaGo, AlphaCode. AlphaCode no es solamente un sistema de inteligencia artificial que sepa generar código que sea funcional, que podamos ejecutar como pasaba con Codex. No. Sino que se trata de la primera inteligencia artificial que es capaz de programar soluciones para problemas de competiciones de programación. Y esto es muy potente. Para el que no haya participado nunca en una competición de este tipo, de lo que estamos hablando es de una competición donde se te va a presentar una serie de problemas computacionales complejos, en el que tienes que presentar ya no solo un nivel de conocimiento del lenguaje de programación que vayas a utilizar, sino también un conocimiento profundo en estructuras de datos, en algoritmos, formas de resolver estos problemas, y también una cierta inteligencia y creatividad a la hora de desarrollar tu programa. Puesto que este ya no solamente tiene que funcionar correctamente, sino que además tiene que hacerlo sin abusar de los recursos computacionales de tiempo y memoria. Vamos, que por lo general no vale desarrollar un algoritmo que resuelva ese problema por fuerza bruta. De hecho, para ilustrarlo mejor, déjame que te enseñe uno de estos problemas, uno de estos desafíos que AlphaCode ha sabido resolver. Backspace. El enunciado dice así. Imagínate que te doy dos cadenas de textos como estas, S y T. Ahora imagínate que tú puedes escribir cada carácter de esta palabra uno a uno, pero como alternativa a pulsar la tecla correcta, también puedes pulsar cuando tú quieras la tecla Backspace, la tecla de borrar. Eso significa que en el momento en el que tú decidas, en vez de escribir un carácter, pues puedes tomar la decisión de borrar el último que has escrito. Por ejemplo, una opción podría ser escribir todos los caracteres de la palabra y punto. O otra opción podría ser escribir los primeros dos caracteres, luego pulsar borrar, por lo cual perdemos uno, luego pulsar otros dos caracteres y luego borrar de nuevo, acabando con este texto de aquí. Y así podrías tener un montón de combinaciones donde escribir caracteres y borrar que te van a llevar a diferentes palabras resultantes. ¿Y cuál es tu tarea? Pues crear un algoritmo que te diga si hay alguna forma en la que con este mecanismo de escritura tú podrías obtener la palabra T. Como se puede ver, no es una tarea sencilla. Ya solamente leer el enunciado te va a llevar una serie de minutos hasta tener un conocimiento pleno de exactamente qué es lo que te están pidiendo. Y claro, implementarlo pues ya ni te digo. De hecho, voy a intentarlo. Y fue en este momento cuando Carlos se dio cuenta de que en realidad no había mirado nada de la teoría necesaria para afrontar este tipo de competiciones. Un mínimo de conocimiento de cómo era esto de la programación dinámica o recursividad o cosas así que uno ve en la carrera, pero que luego si no lo utilizas se acaba olvidando. Aquí podemos ver cómo se dedica a hacer lo que mejor sabe. Carabatos en el paint. No, aquí en realidad es un momento donde me paro un poco a pensar realmente cómo plantear el problema. Aunque parece que estoy ahí dedicando mucho tiempo al dibujito. En realidad estoy pensando y el dibujo me sirve un poco para plantear la solución. Y opto por hacer un programa que haga este árbol de operaciones. Al final Backspace te va generando diferentes ramificaciones según la decisión que tomes si es darle a Backspace o no. Y eso lo intento afrontar con recursividad. Estoy creando un método que va a tomar dos strings. Toma también el texto que se va generando y también un índice que indica la posición del carácter. Y donde se ejecutan ambas opciones, la opción de pulsar el Backspace y pulsar el carácter. Esto al final se va repitiendo de forma recursiva y en el momento en el que encuentras que el texto que va generando es equivalente al texto T que te han dado como input, pues te daremos como buena la solución. Y en caso de no encontrarlo o algún caso particular, pues diremos que no, que no la hemos encontrado, devolvemos falso y ya está. Y para mi sorpresa, pues ha funcionado. Los casos de prueba han funcionado correctamente. Así que ya con toda la ilusión del mundo voy a mandar mi solución y me encuentro un primer error. Esto en realidad es un error que me sucede porque tampoco me he parado a investigar la plataforma ni cómo tiene que ser el input de la información. Y lo que hago es ponerme a buscar pues algún ejemplo de código que me pueda servir para ver cómo exactamente se ven los ficheros o cómo se tiene que dar el input. Y bueno, cuando lo encuentro, entonces sí hago la modificación del código y con toda la ilusión del mundo, nuevamente lo mando a la plataforma. Ahora sí parece que funciona, que pasa el primer test, pasa el segundo. Y con el tercero me sale este error de aquí. Time Exit, me he comido los recursos de tiempo, ya lo he comentado antes. Aquí no solamente hay que hacer una solución que funcione, sino también una solución que no se coma los recursos de tiempo y memoria. En este punto ya me empiezo a dar cuenta de que se me acaba el tiempo y que además seguramente esto hay que resolverlo, pues no con recursividad, sino con algún otro tipo de técnica que debería de haber estudiado antes. Y que Alpha Code ha sabido encontrar y con este pensamiento tan doloroso, pues asumo mi derrota y me impongo como castigo a hacer un futuro video explicando cuál es la solución correcta. En cualquier caso, os animo a que vosotros también lo probéis para que así podáis valorar mucho más lo que hace esta inteligencia artificial. Visto así, creo que sabrás valorar mucho más qué es lo que hace Alpha Code, ya que este sistema lo que propone es que tú le vas a poder pasar el enunciado del problema con sus descripciones, con su explicación, con sus ejemplos de input-output, y como resultado pues te va a generar un código que tú vas a poder ejecutar y vas a poder evaluar qué será funcional y qué resolverá este problema. ¿Qué opináis? Vuelvo a lanzar la pregunta que lancé en el video de hace unos meses. ¿Podrá una inteligencia artificial desarrollar el trabajo de un programador? Seguramente la opinión de algunos de vosotros habrá cambiado de hace unos meses al día de hoy. Pero bueno, no nos vamos a adelantar. Primero tenemos que entender cómo funciona este sistema. Y es que el funcionamiento de esta inteligencia artificial también es interesante. Al final estos nuevos sistemas, generadores de códigos, tanto Alpha Code como el antiguo Codex, se están basando en la potencia de estos enormes modelos del lenguaje que venimos entrenando desde hace unos años. En concreto, enormes modelos del lenguaje que se están nutriendo de gigantescos repositorios de código y a través de los cuales pueden aprender exactamente a eso, a poder programar a través de generar línea tras línea de código. Pero en este caso este sistema va más allá. Vamos a verlo. Lo primero que han hecho ha sido tomar un enorme transformer, un tipo muy especial de red neuronal, una arquitectura de deep learning que ya vosotros tenéis que conocer porque hemos hablado de ella en este vídeo de aquí y en este vídeo de aquí. Y lo han entrenado con un dataset de más de 700 gigas de código público de GitHub. Esto sería pues coger a un chaval que no sabe nada y de repente enseñarle un montón de ejemplos de código y un montón de documentación y que él solo pues aprenda a encontrar los patrones en la secuencia de texto que le permita aprender a expresarse con dichos lenguajes de programación. Y esto ya sería similar en funcionamiento a lo que hace Codex. Esto es una especie de GPT-3 pero que ha sido entrenado sobre un enorme repositorio de código. Este sistema ya sabría expresarse en diferentes lenguajes de programación y generar código que resuelva tareas sencillas. Por tanto, ahora que sabe programar, el siguiente paso será prepararlo para las competiciones de programación. Para esto DeepMind ha creado un dataset propio con muchos ejemplos de problemas de competiciones que incluye el enunciado del problema, soluciones en diferentes lenguajes, ejemplos de pruebas que permiten evaluar si una solución es correcta o no e incluso metadatos sobre los problemas. Cuál es su dificultad, con qué tipo de algoritmo se podría resolver. Ojito con esto último porque luego no va a ser útil. La buena noticia es que este dataset, llamado Code Contest, se ha puesto disponible al público. Cualquiera puede acceder a él. Convirtiéndose por tanto en un recurso muy interesante para que otras organizaciones puedan crear sistemas similares. Este dataset se ha reentrenado a la inteligencia artificial, se ha hecho un proceso de fine tuning, acabando así con un sistema que ya no solo sabe programar, sino que también entiende cuáles son las dinámicas de las competiciones de programación. Que es capaz de tomar un enunciado descrito con lenguaje natural y con todas las complejidades que pueda tener, entenderlo, saber qué tiene que hacer y generar un código que implementa una solución para este problema. Bueno, un código no exactamente. Y es que el sistema de DeepMind no crea una respuesta correcta. Ni cientos, ni miles, sino millones de posibles propuestas de código. Y aquí es donde la máquina realmente empieza a demostrar habilidades con las que el humano no cuenta. Un humano en una competición pues no es capaz de imaginarse ni cientos ni miles de soluciones. Con suerte, yo llego a imaginarme una y hasta demasiadas me parecen. Este proceso de generar múltiples soluciones es uno de los puntos claves que diferencian alfacode. La estrategia para generar tantas soluciones diferentes a un único problema se explica de varias formas. Una de ellas es que se le pide al sistema que el 50% de las soluciones estén programadas en Python. Y la otra mitad en C++. Así ya te está garantizando una gran variedad de implementaciones diferentes. Pero además de esto, aquí es donde entran juegos los metadatos que mencionamos antes. ¿Recuerdas que te dije que para cada problema se contaba con una serie de metadatos que te identificaban ¿el tipo de dificultad de un problema o el tipo de algoritmo necesario para resolverlo? Bien, estos datos como es obvio pues no están disponibles para el modelo en el momento de la competición. No tiene sentido que tú le digas a la inteligencia artificial oye, tienes que resolver este problema pero que es muy sencillo y se hace a través de programación dinámica. Eso sería trampas. Pero en el entrenamiento no. Tú en la fase de entrenamiento puedes decirle a la IA oye, para este problema esta es su solución y este es un problema de dificultad media y esta solución está basado en fuerza bruta. Y así lo que puedes conseguir una vez la IA está entrenada es a través de estos metadatos puedes condicionar el tipo de solución que la IA te va a generar. Por ejemplo, para el problema de backspace que hemos visto antes pues tú le puedes decir a la IA oye, este problema es de dificultad media y se resuelve con fuerza bruta y te va a generar un tipo de solución. Y ahora le puedes decir no, no, este problema es sencillo y se resuelve con programación dinámica y te va a generar una solución diferente. Así es como modificando aleatoriamente estos metadatos pues se puede conseguir una generación mucho más diversa de tipos de soluciones que podrían resolver a este problema. Así es como han conseguido que Alpha Code genere este enorme pool de soluciones. Y no creáis que esto es trampa, eh? Que estamos resolviendo este problema a fuerza bruta generando un millón de soluciones. Alpha Code no manda a los evaluadores pues un millón de soluciones que ellos tienen que verificar a ver si hay alguna que esté correcta. No, para actuar en igualdad de condiciones pues la IA tendrá que encontrar una estrategia para a partir de todas estas soluciones de aquí encontrar únicamente aquellas 10 que sean mejores. Esto requiere por tanto encontrar un sistema de filtrado y selección que no es trivial. Y de hecho la solución que han encontrado me parece bastante ingeniosa. La primera estrategia que han establecido es que bueno, pues si el enunciado del problema nos plantea casos de ejemplo pues vamos a ver cuál de todos estos programas lo ejecuta correctamente. Si algún programa fallara esta prueba, ese programa evidentemente está mal. Y con esta estrategia Alpha Code consigue descartar de media un 99% de soluciones. Es decir, la mayoría del código está mal. Y claro, esto es un debate muy interesante porque si consideramos solamente esta parte del sistema de aquí pues no podemos decir que realmente sabe programar. La mayoría de código que genera es incorrecto. Pero claro, Alpha Code no es solamente esto. Alpha Code es esto más la generación de múltiples soluciones más su filtrado. Alpha Code es todo esto. Y si lo tomamos como un sistema al que le damos un enunciado y nos genera una serie de soluciones correctas, pues oye, funciona bien. Pero mi experiencia me dice que habrá mucha gente que considere que esto no es un sistema que sepa programar. Yo en mi caso la duda es que me despierta este proceso de filtrado es qué tan robusto será el sistema si en el enunciado, por ejemplo, no apareciera ningún ejemplo de prueba. Y está claro que nosotros como humanos pues realmente sí nos apoyamos en este tipo de ejemplos para entender mejor qué tenemos que hacer. Pero en realidad podríamos llegar a entender el enunciado y a generar un código que realmente fuera funcional. Y en el caso de Alpha Code pues no lo sé. En cualquier caso, la estrategia de filtrado funciona y para mí el sistema como un todo pues sigue pareciéndome bastante inteligente. Pero nos falta todavía un paso. Ya hemos filtrado este enorme número de soluciones y ahora nos hemos quedado solo con miles de ellas. ¿Ahora qué? Pues el último punto del sistema es clasterizar. Encontrar cúmulos de código, y esto es interesante, que sean similares semánticamente. Es decir, códigos que independientemente si están escritos de formas diferentes, la lógica que implementen sea la misma. Por ejemplo, este código de aquí y este de aquí pues no se parecen en nada. Pero tienes que saber qué hacen lo mismo. ¿Y cómo lo puedo saber? Pues mira, si para un mismo input generan un output que es similar es que su comportamiento interno pues también tiene que ser similar. Por tanto, cada claster representará soluciones que son funcionalmente diferentes. Y ahora de cada uno de ellos, de mayor a menor, se ha ido seleccionando a cada una de las soluciones candidatas que presentaremos como output final. Estas serán las diez soluciones para nuestro problema. Y así es como Alpha Code funciona y cómo ha conseguido posicionarse más o menos a mitad de tabla en una competición real contra programadores humanos. Y aunque se está hablando de que si en este tipo de competiciones, en la parte de la cola de la tabla, pues realmente lo que nos encontramos son estudiantes de programación que no tienen el nivel suficiente, sinceramente me da igual. El hecho de tener un sistema como Alpha Code que es capaz de resolver algunos de los problemas que hemos podido ver en este video es verdaderamente impresionante y es un nuevo y gran paso en este camino que ya se abrió con Codex el verano del año pasado. Hoy estamos aquí, pero si DeepMind ha demostrado algo durante los últimos años es que cuando se proponen solucionar un problema tardan muy pocas iteraciones en conseguirlo. Y el problema que se han propuesto es la automatización de la programación. Y esta es solo la iteración número uno. Y ya os oigo gritar en los comentarios que si es Kainet, que si la IA nos va a comer, que si es Kainet, que si es Kainet, sois unos pesados. Pero sobre esto hay algo curioso que os voy a comentar. Pero antes déjame recordarte que si este contenido te ha gustado, si quieres apoyar este proyecto, que este conocimiento sobre tecnología de vanguardia esté aquí en YouTube, pues lo puedes apoyar a través de Patreon. Patreon es una plataforma donde vosotros podéis apoyar de forma activa que este contenido exista. Podéis hacer una aportación mensual, ya sea la cantidad que sea, si queréis apoyarlo, si queréis formar parte de esta revolución de la inteligencia artificial, pues abajo en la caja de descripción tenéis un enlace, podéis entrar ahí, podéis registraros rápidamente y con eso podéis apoyar a este canal. Y ahora vamos con lo de Skainet. Y es que hay una curiosidad sobre este paper que me ha llamado mucho la atención. Siempre está esta broma de Skainet, siempre me la ponéis en los comentarios, desde el vídeo número uno me lo habéis puesto. Pero me ha llamado la atención encontrarme un párrafo que hace referencia a algo en esta línea. En esta pre-publicación a la hora de identificar los diferentes riesgos que podrían estar asociados a un sistema como este, DeepMind hace una muy buena identificación de muchos de los ricos que podemos encontrar, pero acaban con este párrafo de aquí, donde nos hablan de riesgos avanzados de inteligencia artificial. Exactamente lo que dicen es lo siguiente. En el largo plazo la generación de código nos podría llevar a riesgos avanzados en inteligencia artificial. Las capacidades de programación nos podrían llevar a sistemas que recursivamente puedan escribir y mejorarse a sí mismos. Rápidamente llevándonos a sistemas más y más avanzados.
